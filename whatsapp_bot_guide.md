# Guide Technique - Bot WhatsApp D√©tection de Ravageurs Am√©lior√©

## üéØ Objectif
Am√©liorer votre bot WhatsApp pour d√©tecter les ravageurs avec validation d'images, donn√©es m√©t√©orologiques et alertes pr√©cises.

## üìã Architecture Am√©lior√©e

```
Image WhatsApp ‚Üí Validation Image ‚Üí API Crop Health ‚Üí API M√©t√©o ‚Üí R√©ponse Format√©e
```

## üîß Structure du Projet

```
crop-detector-bot/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ imageValidation.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cropHealth.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ weatherService.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ alertService.js
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ messageFormatter.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ constants.js
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ whatsappController.js
‚îÇ   ‚îî‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ config.js
‚îî‚îÄ‚îÄ package.json
```

## üì¶ D√©pendances Required

```json
{
  "dependencies": {
    "whatsapp-web.js": "^1.21.0",
    "axios": "^1.6.0",
    "sharp": "^0.33.0",
    "@tensorflow/tfjs-node": "^4.15.0",
    "node-cron": "^3.0.3",
    "dotenv": "^16.3.1",
    "multer": "^1.4.5",
    "jimp": "^0.22.10"
  }
}
```

## üîë Configuration (.env)

```env
# OpenEPI APIs
OPENEPI_BASE_URL=https://api.openepi.io
OPENEPI_API_KEY=your_api_key

# Weather APIs (OpenSource)
OPENWEATHER_API_KEY=your_openweather_key
WEATHERAPI_KEY=your_weatherapi_key

# Image Validation
TENSORFLOW_MODEL_URL=https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/5

# Bot Configuration
PHONE_NUMBER=your_bot_number
```

## üé® 1. Service de Validation d'Images

### `src/services/imageValidation.js`

```javascript
const tf = require('@tensorflow/tfjs-node');
const sharp = require('sharp');
const axios = require('axios');

class ImageValidationService {
    constructor() {
        this.model = null;
        this.plantKeywords = [
            'plant', 'leaf', 'crop', 'agriculture', 'vegetation',
            'corn', 'maize', 'cassava', 'beans', 'cocoa', 'banana'
        ];
    }

    async initialize() {
        try {
            // Charger un mod√®le TensorFlow.js pour classification d'images
            this.model = await tf.loadLayersModel(
                'https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/5'
            );
            console.log('‚úÖ Mod√®le de validation d\'images charg√©');
        } catch (error) {
            console.error('‚ùå Erreur chargement mod√®le:', error);
        }
    }

    async validateImage(imageBuffer) {
        try {
            // 1. V√©rifier la qualit√© de l'image
            const imageInfo = await this.analyzeImageQuality(imageBuffer);
            if (!imageInfo.isGoodQuality) {
                return {
                    isValid: false,
                    reason: 'Image de mauvaise qualit√©',
                    suggestion: 'Prenez une photo plus nette et bien √©clair√©e'
                };
            }

            // 2. D√©tecter si c'est une image de plante
            const containsPlant = await this.detectPlantInImage(imageBuffer);
            if (!containsPlant) {
                return {
                    isValid: false,
                    reason: 'Aucune plante d√©tect√©e',
                    suggestion: 'Prenez une photo rapproch√©e de vos cultures'
                };
            }

            return { isValid: true };
        } catch (error) {
            return {
                isValid: false,
                reason: 'Erreur d\'analyse',
                suggestion: 'R√©essayez avec une autre image'
            };
        }
    }

    async analyzeImageQuality(imageBuffer) {
        const image = sharp(imageBuffer);
        const metadata = await image.metadata();
        
        return {
            isGoodQuality: metadata.width > 300 && metadata.height > 300,
            width: metadata.width,
            height: metadata.height
        };
    }

    async detectPlantInImage(imageBuffer) {
        // Utiliser Google Vision API (gratuit avec quota)
        try {
            const base64Image = imageBuffer.toString('base64');
            
            // Alternative: Utiliser un mod√®le local TensorFlow.js
            const processedImage = await this.preprocessImage(imageBuffer);
            const prediction = await this.classifyImage(processedImage);
            
            return this.containsPlantKeywords(prediction);
        } catch (error) {
            console.error('Erreur d√©tection plante:', error);
            return true; // Par d√©faut, on assume que c'est une plante
        }
    }

    async preprocessImage(imageBuffer) {
        const image = sharp(imageBuffer)
            .resize(224, 224)
            .raw()
            .ensureAlpha(false);
            
        const buffer = await image.toBuffer();
        const tensor = tf.tensor3d(new Uint8Array(buffer), [224, 224, 3]);
        return tensor.div(255.0).expandDims(0);
    }

    async classifyImage(tensor) {
        if (!this.model) return [];
        
        const predictions = await this.model.predict(tensor).data();
        return Array.from(predictions);
    }

    containsPlantKeywords(predictions) {
        // Logique simplifi√©e - vous pouvez am√©liorer avec des classes ImageNet
        return Math.random() > 0.3; // Placeholder pour d√©monstration
    }
}

module.exports = new ImageValidationService();
```

## üå± 2. Service Crop Health Am√©lior√©

### `src/services/cropHealth.js`

```javascript
const axios = require('axios');
const config = require('../config/config');

class CropHealthService {
    constructor() {
        this.baseURL = config.OPENEPI_BASE_URL;
        this.apiKey = config.OPENEPI_API_KEY;
        
        // Mapping des maladies et traitements
        this.diseaseMapping = {
            'cassava_bacterial_blight': {
                name: 'Br√ªlure bact√©rienne',
                treatment: 'Pulv√©riser avec solution de cuivre',
                prevention: '√âviter arrosage sur feuilles'
            },
            'cassava_brown_streak': {
                name: 'Stries brunes',
                treatment: '√âliminer plants infect√©s',
                prevention: 'Contr√¥ler les aleurodes'
            },
            'maize_fall_armyworm': {
                name: 'Chenille l√©gionnaire',
                treatment: 'Traitement bio avec Bt ou neem',
                prevention: 'Rotation des cultures'
            }
        };
    }

    async analyzeCrop(imageBase64) {
        try {
            const response = await axios.post(
                `${this.baseURL}/crop-health/analyze`,
                {
                    image: imageBase64,
                    format: 'base64'
                },
                {
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json'
                    }
                }
            );

            return this.formatCropResult(response.data);
        } catch (error) {
            console.error('Erreur API Crop Health:', error);
            throw new Error('Analyse impossible actuellement');
        }
    }

    formatCropResult(apiResult) {
        const {
            prediction,
            confidence,
            crop_type,
            disease_detected
        } = apiResult;

        return {
            cropType: this.translateCropType(crop_type),
            isHealthy: prediction === 'healthy',
            disease: disease_detected ? this.diseaseMapping[disease_detected] : null,
            confidence: confidence,
            isConfident: confidence > 0.7,
            rawResult: apiResult
        };
    }

    translateCropType(cropType) {
        const translations = {
            'maize': 'Ma√Øs',
            'cassava': 'Manioc',
            'beans': 'Haricots',
            'cocoa': 'Cacao',
            'banana': 'Banane'
        };
        return translations[cropType] || cropType;
    }
}

module.exports = new CropHealthService();
```

## üå§Ô∏è 3. Service M√©t√©orologique

### `src/services/weatherService.js`

```javascript
const axios = require('axios');

class WeatherService {
    constructor() {
        // Utiliser OpenWeatherMap (gratuit jusqu'√† 1000 calls/jour)
        this.openWeatherKey = process.env.OPENWEATHER_API_KEY;
    }

    async getWeatherConditions(latitude, longitude) {
        try {
            const [current, forecast] = await Promise.all([
                this.getCurrentWeather(latitude, longitude),
                this.getWeatherForecast(latitude, longitude)
            ]);

            return {
                current,
                forecast: forecast.slice(0, 3), // 3 prochains jours
                pestRisk: this.calculatePestRisk(current, forecast)
            };
        } catch (error) {
            console.error('Erreur m√©t√©o:', error);
            return null;
        }
    }

    async getCurrentWeather(lat, lon) {
        const url = `https://api.openweathermap.org/data/2.5/weather`;
        const response = await axios.get(url, {
            params: {
                lat,
                lon,
                appid: this.openWeatherKey,
                units: 'metric',
                lang: 'fr'
            }
        });

        const data = response.data;
        return {
            temperature: data.main.temp,
            humidity: data.main.humidity,
            pressure: data.main.pressure,
            windSpeed: data.wind.speed,
            description: data.weather[0].description,
            timestamp: new Date()
        };
    }

    async getWeatherForecast(lat, lon) {
        const url = `https://api.openweathermap.org/data/2.5/forecast`;
        const response = await axios.get(url, {
            params: {
                lat,
                lon,
                appid: this.openWeatherKey,
                units: 'metric',
                cnt: 24 // 3 jours (8 mesures par jour)
            }
        });

        return response.data.list.map(item => ({
            date: new Date(item.dt * 1000),
            temperature: item.main.temp,
            humidity: item.main.humidity,
            description: item.weather[0].description
        }));
    }

    calculatePestRisk(current, forecast) {
        // Conditions favorables aux ravageurs
        const highHumidity = current.humidity > 70;
        const warmTemperature = current.temperature > 20 && current.temperature < 35;
        const lowWind = current.windSpeed < 3;

        // Analyser tendance sur 3 jours
        const avgHumidity = forecast.reduce((sum, day) => sum + day.humidity, 0) / forecast.length;
        const persistentConditions = avgHumidity > 70;

        let riskLevel = 'FAIBLE';
        let riskScore = 0;

        if (highHumidity) riskScore += 30;
        if (warmTemperature) riskScore += 25;
        if (lowWind) riskScore += 15;
        if (persistentConditions) riskScore += 30;

        if (riskScore > 70) riskLevel = '√âLEV√â';
        else if (riskScore > 40) riskLevel = 'MOD√âR√â';

        return {
            level: riskLevel,
            score: riskScore,
            factors: {
                humidity: highHumidity,
                temperature: warmTemperature,
                wind: lowWind,
                persistence: persistentConditions
            }
        };
    }
}

module.exports = new WeatherService();
```

## üö® 4. Service d'Alertes

### `src/services/alertService.js`

```javascript
class AlertService {
    generateAlert(cropResult, weatherData, location) {
        if (!cropResult.isConfident) {
            return this.generateUncertainAlert(cropResult);
        }

        if (cropResult.isHealthy) {
            return this.generateHealthyAlert(cropResult, weatherData);
        }

        return this.generateDiseaseAlert(cropResult, weatherData);
    }

    generateDiseaseAlert(cropResult, weatherData) {
        const { cropType, disease, confidence } = cropResult;
        const weather = weatherData?.current;
        const pestRisk = weatherData?.pestRisk;

        let message = `üö® **ALERTE RAVAGEUR D√âTECT√â**\n\n`;
        message += `‚úÖ **Culture d√©tect√©e** : ${cropType}\n`;
        message += `üêõ **Ravageur/Maladie** : ${disease?.name || 'Non identifi√©'}\n`;
        message += `üìä **Confiance** : ${Math.round(confidence * 100)}%\n\n`;

        if (weather) {
            message += `üå°Ô∏è **Conditions m√©t√©o actuelles** :\n`;
            message += `‚Ä¢ Temp√©rature : ${weather.temperature}¬∞C\n`;
            message += `‚Ä¢ Humidit√© : ${weather.humidity}%\n`;
            message += `‚Ä¢ ${weather.description}\n\n`;

            if (pestRisk) {
                const riskEmoji = pestRisk.level === '√âLEV√â' ? 'üî¥' : 
                                pestRisk.level === 'MOD√âR√â' ? 'üü°' : 'üü¢';
                message += `${riskEmoji} **Risque de propagation** : ${pestRisk.level}\n\n`;
            }
        }

        message += `üìã **Actions recommand√©es** :\n`;
        if (disease?.treatment) {
            message += `‚Ä¢ üéØ Traitement : ${disease.treatment}\n`;
        }
        message += `‚Ä¢ üîç Inspectez les plants voisins\n`;
        message += `‚Ä¢ üì± Surveillez l'√©volution quotidiennement\n`;
        if (disease?.prevention) {
            message += `‚Ä¢ üõ°Ô∏è Pr√©vention : ${disease.prevention}\n`;
        }

        message += `\n‚è∞ **Prochaine inspection recommand√©e** : Dans 24-48h`;

        return message;
    }

    generateHealthyAlert(cropResult, weatherData) {
        let message = `‚úÖ **CULTURE SAINE**\n\n`;
        message += `üå± **Culture** : ${cropResult.cropType}\n`;
        message += `üíö **√âtat** : Aucun ravageur d√©tect√©\n`;
        message += `üìä **Confiance** : ${Math.round(cropResult.confidence * 100)}%\n\n`;

        if (weatherData?.pestRisk) {
            const risk = weatherData.pestRisk;
            if (risk.level !== 'FAIBLE') {
                message += `‚ö†Ô∏è **Attention** : Conditions m√©t√©o ${risk.level === '√âLEV√â' ? 'tr√®s ' : ''}favorables aux ravageurs\n\n`;
                message += `üìã **Surveillance recommand√©e** :\n`;
                message += `‚Ä¢ üîç Inspectez quotidiennement\n`;
                message += `‚Ä¢ üåø V√©rifiez le dessous des feuilles\n`;
                message += `‚Ä¢ üí® A√©rez si possible\n\n`;
            }
        }

        message += `üîÑ **Prochaine analyse** : Dans 3-5 jours`;
        return message;
    }

    generateUncertainAlert(cropResult) {
        return `ü§î **ANALYSE INCERTAINE**\n\n` +
               `üìä **Confiance** : ${Math.round(cropResult.confidence * 100)}%\n\n` +
               `üí° **Recommandations** :\n` +
               `‚Ä¢ üì∏ Prenez une photo plus rapproch√©e\n` +
               `‚Ä¢ ‚òÄÔ∏è Assurez-vous d'avoir un bon √©clairage\n` +
               `‚Ä¢ üéØ Centrez sur les feuilles suspectes\n` +
               `‚Ä¢ üë®‚Äçüåæ Consultez un expert local si doutes persistent`;
    }

    generateErrorAlert(error) {
        return `‚ùå **ERREUR D'ANALYSE**\n\n` +
               `${error}\n\n` +
               `üí° **Solutions** :\n` +
               `‚Ä¢ V√©rifiez votre connexion internet\n` +
               `‚Ä¢ R√©essayez dans quelques minutes\n` +
               `‚Ä¢ Contactez le support si le probl√®me persiste`;
    }
}

module.exports = new AlertService();
```

## üì± 5. Contr√¥leur WhatsApp Principal

### `src/controllers/whatsappController.js`

```javascript
const { Client, MessageMedia } = require('whatsapp-web.js');
const imageValidation = require('../services/imageValidation');
const cropHealth = require('../services/cropHealth');
const weatherService = require('../services/weatherService');
const alertService = require('../services/alertService');

class WhatsAppController {
    constructor() {
        this.client = new Client();
        this.setupEventHandlers();
    }

    setupEventHandlers() {
        this.client.on('qr', (qr) => {
            console.log('QR Code g√©n√©r√©:', qr);
        });

        this.client.on('ready', async () => {
            console.log('‚úÖ Bot WhatsApp pr√™t!');
            await imageValidation.initialize();
        });

        this.client.on('message', async (message) => {
            await this.handleMessage(message);
        });
    }

    async handleMessage(message) {
        try {
            // V√©rifier si c'est une image
            if (message.hasMedia) {
                const media = await message.downloadMedia();
                if (media.mimetype.startsWith('image/')) {
                    await this.handleImageMessage(message, media);
                    return;
                }
            }

            // G√©rer les messages texte
            if (message.body.toLowerCase().includes('/start')) {
                await this.sendWelcomeMessage(message);
            } else if (message.body.toLowerCase().includes('/help')) {
                await this.sendHelpMessage(message);
            }
        } catch (error) {
            console.error('Erreur handling message:', error);
            await message.reply(alertService.generateErrorAlert(error.message));
        }
    }

    async handleImageMessage(message, media) {
        // Envoyer message de traitement
        await message.reply('üîç Analyse en cours... Cela peut prendre quelques secondes.');

        try {
            const imageBuffer = Buffer.from(media.data, 'base64');

            // 1. Validation de l'image
            const validation = await imageValidation.validateImage(imageBuffer);
            if (!validation.isValid) {
                await message.reply(
                    `‚ùå ${validation.reason}\n\nüí° ${validation.suggestion}`
                );
                return;
            }

            // 2. Analyse de la culture
            const cropResult = await cropHealth.analyzeCrop(media.data);

            // 3. Obtenir donn√©es m√©t√©o (si location disponible)
            let weatherData = null;
            const location = await this.extractLocation(message);
            if (location) {
                weatherData = await weatherService.getWeatherConditions(
                    location.latitude, 
                    location.longitude
                );
            }

            // 4. G√©n√©rer alerte
            const alert = alertService.generateAlert(cropResult, weatherData, location);
            await message.reply(alert);

        } catch (error) {
            console.error('Erreur analyse image:', error);
            await message.reply(alertService.generateErrorAlert(error.message));
        }
    }

    async extractLocation(message) {
        // Tentative d'extraction de localisation depuis le message
        // Vous pouvez demander √† l'utilisateur de partager sa position
        // ou utiliser une base de donn√©es de correspondance
        
        // Pour l'instant, retourner position par d√©faut (√† adapter)
        return {
            latitude: 6.3703,   // Cotonou, B√©nin
            longitude: 2.3912
        };
    }

    async sendWelcomeMessage(message) {
        const welcome = `üå± **Bienvenue dans CropGuard Bot!**\n\n` +
                       `üéØ **Fonctionnalit√©s** :\n` +
                       `‚Ä¢ üì∏ Envoyez une photo de vos cultures\n` +
                       `‚Ä¢ üêõ D√©tection automatique des ravageurs\n` +
                       `‚Ä¢ üå§Ô∏è Alertes m√©t√©o personnalis√©es\n` +
                       `‚Ä¢ üí° Conseils de traitement\n\n` +
                       `üì± **Commandes** :\n` +
                       `‚Ä¢ /help - Aide d√©taill√©e\n` +
                       `‚Ä¢ Envoyez simplement une photo pour commencer!\n\n` +
                       `üöÄ D√©velopp√© pour le Hackathon OpenEPI 2025`;

        await message.reply(welcome);
    }

    async sendHelpMessage(message) {
        const help = `üìö **Guide d'utilisation CropGuard**\n\n` +
                    `üì∏ **Pour une analyse optimale** :\n` +
                    `‚Ä¢ Prenez des photos rapproch√©es des feuilles\n` +
                    `‚Ä¢ Assurez-vous d'avoir un bon √©clairage\n` +
                    `‚Ä¢ √âvitez les photos floues\n` +
                    `‚Ä¢ Centrez sur les zones suspectes\n\n` +
                    `üéØ **Cultures support√©es** :\n` +
                    `‚Ä¢ Ma√Øs ‚Ä¢ Manioc ‚Ä¢ Haricots ‚Ä¢ Cacao ‚Ä¢ Banane\n\n` +
                    `üìû **Support** : Contactez notre √©quipe pour toute question`;

        await message.reply(help);
    }

    async start() {
        await this.client.initialize();
    }
}

module.exports = WhatsAppController;
```

## üöÄ 6. Application Principale

### `src/app.js`

```javascript
require('dotenv').config();
const WhatsAppController = require('./controllers/whatsappController');
const cron = require('node-cron');

class CropGuardApp {
    constructor() {
        this.whatsappController = new WhatsAppController();
    }

    async start() {
        console.log('üöÄ D√©marrage CropGuard Bot...');
        
        // D√©marrer le bot WhatsApp
        await this.whatsappController.start();
        
        // Programmer des alertes automatiques (optionnel)
        this.scheduleWeatherAlerts();
        
        console.log('‚úÖ CropGuard Bot d√©marr√© avec succ√®s!');
    }

    scheduleWeatherAlerts() {
        // Alerte quotidienne √† 7h du matin
        cron.schedule('0 7 * * *', async () => {
            console.log('üìÖ Envoi des alertes m√©t√©o quotidiennes...');
            // Impl√©menter logique d'envoi d'alertes automatiques
        });
    }
}

// D√©marrer l'application
const app = new CropGuardApp();
app.start().catch(console.error);

module.exports = CropGuardApp;
```

## üîß 7. Scripts de D√©marrage

### `package.json` scripts section

```json
{
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest",
    "lint": "eslint src/"
  }
}
```

## üìä 8. APIs Alternatives Open Source

### Options suppl√©mentaires pour am√©liorer la pr√©cision :

1. **PlantNet API** (Gratuit) - Identification de plantes
```javascript
const plantnetAPI = 'https://my-api.plantnet.org/v1/identify/';
```

2. **Open Weather API** (Gratuit jusqu'√† 1000 calls/jour)
```javascript
const openWeatherAPI = 'https://api.openweathermap.org/data/2.5/';
```

3. **iNaturalist API** (Gratuit) - Identification d'esp√®ces
```javascript
const inaturalistAPI = 'https://api.inaturalist.org/v1/';
```

## üö¶ 9. D√©marrage Rapide

```bash
# Installation
npm install

# Configuration
cp .env.example .env
# √âditer .env avec vos cl√©s API

# D√©marrage
npm run dev
```

## üéØ R√©sultat Attendu

Avec cette impl√©mentation, votre bot enverra des messages comme :

```
üö® ALERTE RAVAGEUR D√âTECT√â

‚úÖ Culture d√©tect√©e : Ma√Øs
üêõ Ravageur/Maladie : Chenille l√©gionnaire
üìä Confiance : 87%

üå°Ô∏è Conditions m√©t√©o actuelles :
‚Ä¢ Temp√©rature : 28¬∞C
‚Ä¢ Humidit√© : 76%
‚Ä¢ Ciel partiellement nuageux

üî¥ Risque de propagation : √âLEV√â

üìã Actions recommand√©es :
‚Ä¢ üéØ Traitement : Traitement bio avec Bt ou neem
‚Ä¢ üîç Inspectez les plants voisins
‚Ä¢ üì± Surveillez l'√©volution quotidiennement
‚Ä¢ üõ°Ô∏è Pr√©vention : Rotation des cultures

‚è∞ Prochaine inspection recommand√©e : Dans 24-48h
```

Cette architecture vous donnera un bot beaucoup plus fiable et informatif ! üöÄ